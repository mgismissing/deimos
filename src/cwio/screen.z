use .calc
use * from .const
use Font from .font
use utime

def on: None
    calc.write(SCR.POWER, SCR.ENUM.POWER.RESET)
    utime.sleep_ms(2)
    calc.write(SCR.POWER, SCR.ENUM.POWER.ON)
    utime.sleep_ms(2)
.

def init: None
    calc.write(SCR.MODE, SCR.ENUM.MODE.BUFFER | SCR.ENUM.MODE.ALL | SCR.ENUM.MODE.FLIP_X | SCR.ENUM.MODE.COLOR)
    calc.write(SCR.CONTRAST, 0x13)
    utime.sleep_ms(2)
.

empty = [
    (b"\x00" * (SCR.SIZE-SCR.HEADER*SCR.WIDTH_B)) as bytearray,
    (b"\x00" * (SCR.SIZE-SCR.HEADER*SCR.WIDTH_B)) as bytearray,
]
oldbuf = None
buf = [empty[0][0:], empty[1][0:],]

def clear
    for i -> {->SCR.SIZE-SCR.HEADER*SCR.WIDTH_B}
        buf[0][i] = 0x00
        buf[1][i] = 0x00
    .
.

def get_group(x: int, y: int, pl: int)
    <-buf[pl][y * SCR.WIDTH_B + x // 8]
.

def set_group(x: int, y: int, pl: int, v: int)
    buf[pl][y * SCR.WIDTH_B + x // 8] = v
.

def paint_group(x: int, y: int, pl: int, b: int, m: bool)
    i = y * SCR.WIDTH_B + x // 8
    if m;  buf[pl][i] |= b
    .else; buf[pl][i] &=~b
    .
.

def set_raw(x: int, y: int, pl: int, v: bool)
    ox = x % 8
    paint_group(x, y, pl, 1 << (7 - ox), v)
.

def set(x: int, y: int, v: int): None
    set_raw(x, y, 0, v & SCR.ENUM.PIXEL.BRIGHT)
    set_raw(x, y, 1, v & SCR.ENUM.PIXEL.DARK)
.

def set_byte(x: int, y: int, v: int): None
    set_group(x, y, 0, (v & SCR.ENUM.PIXEL.BRIGHT) * 0xFF)
    set_group(x, y, 1, ((v & SCR.ENUM.PIXEL.DARK) >> 1) * 0xFF)
.

def apply: None
    global oldbuf
    global buf
    for rp at p -> [SCR.ENUM.SELECT.PLANE0, SCR.ENUM.SELECT.PLANE1,]
        calc.write(SCR.SELECT, rp)
        for y -> {->SCR.HEIGHT}
            for x -> {->SCR.WIDTH_B}
                i = y * SCR.WIDTH_B + x
                if (not oldbuf) or (oldbuf[p][i] != buf[p][i])
                    calc.write(
                        SCR.BUFFER + (y+1) * SCR.TRUE_WIDTH_B + x,
                        buf[p][i]
                    )
                .
            .
        .
    .
    oldbuf = [
        buf[0][0:],
        buf[1][0:],
    ]
.

def line_h(x: int, y: int, l: int, v: int)
    s = 0
    rx = x
    rl = x+l
    while rx < rl
        if s == 0
            if rx % 8
                set(rx, y, v)
                rx += 1
            .else
                s = 1
            .
        .elif s == 1
            if rl-rx >= 8
                set_byte(rx, y, v)
                rx += 8
            .else
                s = 2
            .
        .else
            set(rx, y, v)
            rx += 1
        .
    .
.

def line_v(x: int, y: int, l: int, v: int)
    for oy -> {->l}
        set(x, y+oy, v)
    .
.

def box(x: int, y: int, w: int, h: int, v: int)
    line_h(x, y, w, v)
    line_h(x, y+h-1, w, v)
    line_v(x, y+1, h-2, v)
    line_v(x+w-1, y+1, h-2, v)
.

def rect(x: int, y: int, w: int, h: int, v: int)
    for oy -> {->h}
        line_h(x, y+oy, w, v)
    .
.

class Image
    /* @w: int, @h: int, @data: bytes;;.
.

class MonoImage from Image;;.

def image(img: MonoImage, x: int, y: int, v: int): None
    === start of previous x byte
    xb = x//8
    === actual row size in bytes
    wb = ((img.w+7)&~7)//8
    for py -> {->img.h}
        for bx -> {->wb}
            === x offset from last byte
            ox = x % 8
            === current byte's address in font data
            r = py * wb + bx
            === previous, current and next bytes in row
            prevb = (0x00 if bx == 0 else img.data[r-1])
            currb = img.data[r]
            nextb = (0x00 if bx == wb-1 else img.data[r+1])
            === generate brush by merging all 3 bytes next to each other
            brush = (prevb << 16) | (currb << 8) | nextb
            === get the byte that gets drawn on screen
            === by offsetting the brush by the x offset
            byte = brush >> (8 + ox)
            === draw the byte on the screen if it contains data
            if byte
                paint_group(x + bx * 8, y + py, 0, byte, True)
                paint_group(x + bx * 8, y + py, 1, byte, True)
            .
            === draw the remaining part if it's being cut off by the byte border
            byte = brush >> ox
            if byte
                paint_group(x + (bx+1) * 8, y + py, 0, byte, True)
                paint_group(x + (bx+1) * 8, y + py, 1, byte, True)
            .
        .
    .
.

def write_char(c: str, x: int, y: int, v: int, font: Font): None
    f = font!
    char = getattr(f, "c"..(c as ord as hex as str)[2:].upper!, None)
    if not char; <-;.
    image(MonoImage(f.w, f.h, char), x, y, v)
.

def write(s: str, x: int, y: int, v: int, font: Font): None
    f = font!
    ox = 0
    oy = 0
    for c -> s
        if c == "\n"
            ox = 0
            oy += 1
        .elif c == "\r"
            ox = 0
        .elif c == "\b"
            ox -= (1 if ox > 0 else 0)
        .else
            write_char(c, x + ox * f.w, y + oy * f.h, v, font)
            ox += 1
        .
    .
.