use * from cwio
use * from cwio.const
use MonoImage from cwio.screen
use math
use ui

name = "Calculator"

def clamp(min: int, max: int, n: int)
    if (n between min, max)
        <-n
    .elif n < min
        <-min
    .else
        <-max
    .
.

def reprover(s: str | None = None)
    class Function
        /* @func
            @.name = s or @.func.__name__
        .
        /! *args, **kwargs
            <-@.func(*args, **kwargs)
        .
        /repr; <-@.name;.
    .
    def decorator(f)
        <-Function(f)
    .
    <-decorator
.

class func
    @reprover("sin")
    def sin(a: int | float); <-math.sin(math.radians(a));.
    @reprover("cos")
    def cos(a: int | float); <-math.cos(math.radians(a));.
    @reprover("tan")
    def tan(a: int | float); <-math.tan(math.radians(a));.
    @reprover("sin\uE011")
    def asin(a: int | float); <-math.asin(math.radians(a));.
    @reprover("cos\uE011")
    def acos(a: int | float); <-math.acos(math.radians(a));.
    @reprover("tan\uE011")
    def atan(a: int | float); <-math.atan(math.radians(a));.
    @reprover("\u221A")
    def sqrt(a: int | float); <-math.sqrt(a);.
    @reprover("ask")
    def ask(a: str); <-ui.ask(a as str);.
    @reprover("sel")
    def sel(a: list(str)); <-ui.choose(a as list);.
.
class var
    ans = 0
    x = 0
    y = 0
    z = 0
.

replaces = [
    "\uF000" = ["sin",        "func.sin"  ],
    "\uF001" = ["sin\uE011",  "func.asin" ],
    "\uF002" = ["cos",        "func.cos"  ],
    "\uF003" = ["cos\uE011",  "func.acos" ],
    "\uF004" = ["tan",        "func.tan"  ],
    "\uF005" = ["tan\uE011",  "func.atan" ],
    "\uF006" = ["\u221A",     "func.sqrt" ],
    "\uF007" = ["Ans",        "var.ans"   ],
    "\uF008" = ["ask",        "func.ask"  ],
    "\uF009" = ["sel",        "func.sel"  ],
    "\uF010" = ["\U0001D499", "var.x"     ],
    "\uF011" = ["\U0001D49A", "var.y"     ],
    "\uF012" = ["\U0001D49B", "var.z"     ],
    "^"      = ["^",          "**"        ]
]

def main
    buf = ""
    pos = 0
    get = False
    shift = False
    tools = False
    while True
        screen.clear!
        toprint1 = buf[:pos]
        for k, v -> replaces.items!
            toprint1 .= replace(k, v[0])
        .
        toprint2 = buf[pos:]
        for k, v -> replaces.items!
            toprint2 .= replace(k, v[0])
        .
        toprint = toprint1 + toprint2
        if shift; screen.rect(SCR.WIDTH-10, SCR.HEIGHT-8, 5, 8, SCR.COLOR.BLACK);.
        if tools; screen.rect(SCR.WIDTH-5, SCR.HEIGHT-8, 5, 8, SCR.COLOR.BLACK);.
        screen.write("S", SCR.WIDTH-9, SCR.HEIGHT-8, (SCR.COLOR.WHITE if shift else SCR.COLOR.BLACK), font.miniwi)
        screen.write("T", SCR.WIDTH-4, SCR.HEIGHT-8, (SCR.COLOR.WHITE if tools else SCR.COLOR.BLACK), font.miniwi)
        screen.write(toprint..("=" if get else ""), 0, 0, SCR.COLOR.BLACK, font.classwiz_cw)
        if not get; screen.write("|", 11*#(toprint1.split("\n")[-1]), 14*toprint1.count("\n"), SCR.COLOR.DARK, font.classwiz_cw);.
        if get
            try
                if      buf == "";          ans = "0";
                .elif   buf == "1+1";       ans = "3";
                .elif   buf == "6+7";       ans = "67";
                .elif   buf == "9+10";      ans = "21";
                .elif   buf == "9/11";      ans = "2001";
                .elif   buf == "http";      ans = "200 OK";
                .else
                    expr = buf
                    for k, v -> replaces.items!
                        expr .= replace(k, v[1])
                    .
                    <|"[EVAL] Parsing \""..expr.."\""
                    ans = ""
                    if get == "plot/y"
                        cx = SCR.WIDTH//2
                        cy = SCR.HEIGHT//2
                        screen.clear!
                        screen.line_v(cx, 0, SCR.HEIGHT, SCR.COLOR.DARK)
                        screen.line_h(0, cy, SCR.WIDTH, SCR.COLOR.DARK)
                        for x to SCR.WIDTH
                            var.x = x-cx
                            var.y = eval(expr)
                            y = math.floor(var.y)
                            if y > 0
                                screen.line_v(x, cy-y, y, SCR.COLOR.BRIGHT)
                            .else
                                screen.line_v(x, cy+1, -y-1, SCR.COLOR.BRIGHT)
                            .
                            screen.set(x, math.floor(cy-var.y), SCR.COLOR.BLACK)
                        .
                    .else
                        ans = eval(expr)
                        var.ans = ans
                    .
                .
                result = ans as str
            .catch [SyntaxError, ZeroDivisionError] = e
                result = e as str
                if result.startswith("invalid syntax"); result = "invalid syntax";.
            .catch TypeError = e
                err = e as str
                result = "syntax error"
                if      err.startswith("function takes");;
                .elif   err.startswith("unsupported types");;
                .else
                    raise e
                .
            .catch AttributeError
                result = "invalid syntax"
            .catch NameError
                result = "invalid name"
            .
            <|"[EVAL] Result: \""..result.."\""
            screen.write(result, 0, SCR.HEIGHT-14, SCR.COLOR.BLACK, font.classwiz_cw)
            get = False
        .
        screen.apply!
        while keyboard.pressed_any!;;.
        key = keyboard.get_next!
        chr = None
        mov = 0
        if          key == KB.KEYS.SHIFT
            shift = not $
        .elif       key == KB.KEYS.TOOLS
            tools = not $
        .elif shift and not tools
            shift = False
            tools = False
            if      key == KB.KEYS.LEFT
                pos = 0
            .elif   key == KB.KEYS.RIGHT
                pos = #buf
            .elif   key == KB.KEYS.LPAREN     ; chr = "="
            .elif   key == KB.KEYS.RPAREN     ; chr = ","
            .elif   key == KB.KEYS.MULTIPLY   ; chr = "%"
            .elif   key == KB.KEYS.SIN        ; chr = "\uF001()"; mov--
            .elif   key == KB.KEYS.COS        ; chr = "\uF003()"; mov--
            .elif   key == KB.KEYS.TAN        ; chr = "\uF005()"; mov--
            .elif   key == KB.KEYS.ADD        ; chr = "\"\""; mov--
            .elif   key == KB.KEYS.ANS        ; chr = "\uF008()"; mov-=1
            .elif   key == KB.KEYS.N0         ; chr = "\uF010"
            .elif   key == KB.KEYS.DOT        ; chr = "\uF011"
            .elif   key == KB.KEYS.POWER_10   ; chr = "\uF012"
            .
        .elif tools and not shift
            tools = False
            shift = False
            if      key == KB.KEYS.LPAREN     ; chr = "[]"; mov--
            .elif   key == KB.KEYS.RPAREN     ; chr = "]"
            .elif   key == KB.KEYS.MULTIPLY   ; chr = "!"
            .elif   key == KB.KEYS.DOT        ; chr = ":"
            .elif   key == KB.KEYS.ANS        ; chr = "\uF009([])"; mov-=2
            .elif   key == KB.KEYS.FORMAT     ; chr = "\\"
            .elif   key == KB.KEYS.EXE        ; chr = "\n"
            .
        .elif shift and tools
            shift = False
            tools = False
            if      key == KB.KEYS.RPAREN     ; chr = ";"
            .
        .else
            if      key == KB.KEYS.BKSPACE
                if pos > 0
                    buf = $[:pos-1] + $[pos:]
                    pos -= 1
                .else
                    buf = $[1:]
                .
            .elif   key == KB.KEYS.AC
                buf = ""
                pos = 0
            .elif   key == KB.KEYS.LEFT
                if pos > 0
                    pos -= 1
                .else
                    pos = #buf
                .
            .elif   key == KB.KEYS.RIGHT
                if pos < #buf
                    pos += 1
                .else
                    pos = 0
                .
            .elif   key == KB.KEYS.FORMAT
                chr = ui.ask("Insert text")
            .elif   key == KB.KEYS.CATALOG
                c = ui.choose(["Plot y"])
                if c == 0
                    get = "plot/y"
                .
            .elif   key == KB.KEYS.HOME       ; break
            .elif   key == KB.KEYS.EXE        ; get = True
            .elif   key == KB.KEYS.N0         ; chr = "0"
            .elif   key == KB.KEYS.N1         ; chr = "1"
            .elif   key == KB.KEYS.N2         ; chr = "2"
            .elif   key == KB.KEYS.N3         ; chr = "3"
            .elif   key == KB.KEYS.N4         ; chr = "4"
            .elif   key == KB.KEYS.N5         ; chr = "5"
            .elif   key == KB.KEYS.N6         ; chr = "6"
            .elif   key == KB.KEYS.N7         ; chr = "7"
            .elif   key == KB.KEYS.N8         ; chr = "8"
            .elif   key == KB.KEYS.N9         ; chr = "9"
            .elif   key == KB.KEYS.DOT        ; chr = "."
            .elif   key == KB.KEYS.ADD        ; chr = "+"
            .elif   key == KB.KEYS.SUBTRACT   ; chr = "-"
            .elif   key == KB.KEYS.MULTIPLY   ; chr = "*"
            .elif   key == KB.KEYS.DIVIDE     ; chr = "/"
            .elif   key == KB.KEYS.POWER      ; chr = "^"
            .elif   key == KB.KEYS.POWER_2    ; chr = "^2"
            .elif   key == KB.KEYS.POWER_10   ; chr = "*10^()"; mov--
            .elif   key == KB.KEYS.SIN        ; chr = "\uF000()"; mov--
            .elif   key == KB.KEYS.COS        ; chr = "\uF002()"; mov--
            .elif   key == KB.KEYS.TAN        ; chr = "\uF004()"; mov--
            .elif   key == KB.KEYS.SQRT       ; chr = "\uF006()"; mov--
            .elif   key == KB.KEYS.LPAREN     ; chr = "()"; mov--
            .elif   key == KB.KEYS.RPAREN     ; chr = ")"
            .elif   key == KB.KEYS.ANS        ; chr = "\uF007"
            .elif   key == KB.KEYS.X          ; chr = "\uF010"
            .
        .
        if chr
            buf = buf[:pos] + chr + buf[pos:]
            pos += #chr+mov
        .
        if pos < 0; pos = 0;.
    .
.